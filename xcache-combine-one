#!/usr/bin/python

import os, glob, sys, marshal, shutil

sha = sys.argv[1]
rootdir = sys.argv[2]
cappath = sys.argv[3]
hl = int(sys.argv[4])
clen = int(sys.argv[5])
rs = int(sys.argv[6])
re = int(sys.argv[7])

logf = open('/l/cl', 'a+')

print sha, rootdir, cappath, 'hl', hl, 'clen', clen, 'rs', rs, 're', re

covpath = '%s/R.%s' % (rootdir, sha)
if not os.path.exists(covpath):
	cov = []
else:
	print 'reading %s' % covpath
	cov = marshal.load(open(covpath, 'rb'))['cov']

if filter(lambda x: x[0] <= rs and re <= x[1], cov):
	print 'fail: already covered'
	print
	sys.exit(0)

cov = filter(lambda x: not (rs <= x[0] and x[1] <= re), cov)
cov.append((rs, re))

m = sorted(cov)
newcov = []
print 'covers'
tot = 0
i = 0
while i < len(m):
	s, e = m[i][:2]
	j = i+1
	while j < len(m) and m[j][0] <= e+1 and e+1 <= m[j][1]:
		e = m[j][1]
		j += 1
	i = j
	tot += e - s + 1
	print s, e
	newcov.append((s, e))
print 'tot', tot, 'left', clen - tot

fp = open(cappath, 'r+b')
fp.seek(hl)
fp.truncate(hl+re-rs+1)
resfp = open('%s/F.%s' % (rootdir, sha), 'r+b')
resfp.seek(rs)
shutil.copyfileobj(fp, resfp)

marshal.dump({'clen':clen, 'cov':newcov}, open(covpath, 'wb+'))
print 'ok'


#!/usr/bin/perl

use threads;
use threads::shared;

my (%H, %S, %N) :shared;
%oH = (	
	'f_done', 0, 'f_delsmall', 0, 'f_rst', 0,
	'jmp_pass', 0, 'jmp_mine', 0
);
$mb = 1024*1024.;

sub json {
	%h = @_; 
	'{' . join(',', map { sprintf "\"$_\":%.2lf", $h{$_} } keys %h ) . "}\n"; 
}

sub inc {
	($i) = @_;
	$H{$i}++;
}

sub sum {
	%h = @_;
	for $k (keys %h) {
		$S{$k} += $h{$k};
		$N{$k}++;
	}
}

sub out {
	sum @_;
	print json @_;
}

sub thread_a {
	open F, "tail -f /l/cgi2|";
	while (<F>) {
		inc 'jmp_mine' if /^mine/;
		inc 'jmp_pass' if /^pass/;
	}
}

sub thread_b {
	$| = 1;
	open S, "xcache-stateth |";
	open G, "tail -f -n1 /l/cap|";
	while (<G>) { 
		inc 'f_zio' if /zero-io/;
		inc 'f_rst' if /fin-rst/;
		inc 'f_reget' if /re-get/;
		if (/^info/) {
			($io, $max, $act, $del, $got) = /(\d+)/g;
			out 'io_ssd', $io/$mb, 'ht_max', $max, 'ht_active', $act, \
					'f_delsmall', $del, 'f_got', $got;
		}
	}
}

sub thread_c {
	open H, "tail -f /l/L|";
	while (<H>) {
		if (/Done: (\d+)/) {
			inc 'f_done';
		}
	}
}

sub thread_d {
	$| = 1;
	open I, "top -d1 -b|";
	while (<I>) {
		if (/^Cpu/ && /(\S+)%id/) {
			out 'c_all', 100-$1;
		}
	}
}

sub thread_e {
	$| = 1;
	open S, "xcache-stateth |";
	while (<S>) {
		($a, $b) = /(\d+)/g;
		$ia = $a*8/$mb;
		$ib = $b*8/$mb;
		out 'io_eth0', $ia, 'io_eth1', $ib;
	}
}

sub thread_timer {
	while (1) {
		sleep 2;
#		avg;
	}
}

threads->create(\&thread_a);
threads->create(\&thread_b);
threads->create(\&thread_c);
threads->create(\&thread_d);
threads->create(\&thread_e);
threads->create(\&thread_timer);
while (1) {
	open A, "df |";
	while (<A>) {
		($a, $sz) = /(\d+)/g;
		$d_ssd = $sz if /ssd/;
		$d_hd = $sz if /sdc/;
	}
	close A;
	out 'd_hd', $d_hd/1024./1024, 'd_ssd', $d_ssd/1024./1024, %H;
	sum %H;
	%H = %oH;
	sleep 1;
}

